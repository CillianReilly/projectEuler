// At each step, test adding 1 of each coin and discard where this would bring the total over the target (resetting smaller coins to 0)
// Of the remaining possibilities, choose the one generated by the smallest coin - then fill the remainder with 1's 

// This could also benefit from a dynamic programming approach - there are a lot of repeated calculations
// e.g. shuffling 1's into the 2's column

q)t:sum prd(key;value)@\:
q)f:{@[;1;:;].(x;d)@'?[;1b]not 0>d:last[k]-t each x:(not k</:k)*x+/:k=/:k:key x}
q)count(not last@)f\1 2 5 10 20 50 100 200!200 0 0 0 0 0 0 0

k)t:+/*/(!:;.:)@\:
k)f:{@[;1;:;].(x;d)@'?[;1b]@~0>d:(*|k)-t'x:(~k</:k)*x+/:k=/:k:!x}
k)#(~*|:)f\1 2 5 10 20 50 100 200!200 0 0 0 0 0 0 0
